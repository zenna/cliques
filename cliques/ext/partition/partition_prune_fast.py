#!/usr/bin/python# -*- coding: utf-8 -*-import sysimport osUNIPROJ = os.getenv('UNIPROJ')# class graph(dict):#    def __init__(self):#        self.Deg = []#        self.Adj = {}#        self.AdjLgr = []def from_file(filename):	g = {}	for line in file(filename):		line = line.split()		u = int(line[0])		v = int(line[1])		if u not in g:			g[u] = set()		if v not in g:			g[v] = set()		g[u].add(v)		g[v].add(u)	return gdef from_stdin(b):	g = {}	for line in b:		# print line		line = line.split()		u = int(line[0])		v = int(line[1])		if u not in g:			g[u] = set()		if v not in g:			g[v] = set()		g[u].add(v)		g[v].add(u)	return gdef print_partition(part):	global b	global ii	b.append([])	# print "print_partition, begin"	if len(part) == 0:		print 'print_partition, no sets'	j = 0	for s in part:		if len(s) == 0:			print 'print_partition, empty set'		b[ii].append([])		for v in s:			b[ii][j].append(v)			sys.stdout.write('%s ' % v)		j = j + 1		sys.stdout.write('| ')	ii = ii + 1	sys.stdout.write('\n')	#print "print_partition, end"def gen_conn(v, size):	s_tmp = size	comp = set([v])	s_tmp -= 1# generates all connected sets containing comp_tmp and# size other vertices, with no vertex from the set# forbidden.# neighbours is the set of neighbours of vertices in# comp_tmp that are not in forbiddendef gen_conn_aux_size(	g,	comp_tmp,	size,	neighbours,	forbidden,	):	# print "comp_tmp", comp_tmp, "forbidden", forbidden, "neighbours", neighbours	if size == 0:		print comp_tmp	else:#        return comp_tmp		# if no more neighbours are available and size > 0,		# it is not possible to compute a component		if len(neighbours) == 0:			print 'could not finish'			return#            return set([-1])		# the first vertex in neighbours can belong to a component with size-1 additional vertices,		# or not belong to a component with size additional vertices.#        for v in neighbours:		v = neighbours.pop()		new_comp_tmp = comp_tmp.union(set([v]))		# Must be more efficient way to compute new_neighbours		new_neighbours = neighbours.union(g[v])		if v in new_neighbours:			print 'Problem'		# new_neighbours.remove(v)		new_neighbours.difference_update(forbidden)		gen_conn_aux_size(g, new_comp_tmp, size - 1, new_neighbours,						forbidden)		new_forbidden = forbidden.union(set([v]))		# new_neighbours = neighbours.copy()		# new_neighbours.remove(v)		gen_conn_aux_size(g, comp_tmp, size, neighbours, new_forbidden)# same as above# previous sets contains previously computed parts of the partitions# (all the corresponding vertices must be in forbidden)# nodes_to_place contains all nodes not currently in a set# comp_tmp contains the current part (always contains at least one node)def gen_partitions_aux(	g,	n,	comp_tmp,	neighbours,	forbidden,	previous_sets,	previous_sets_union,	nodes_to_place,	):	# if previous_sets_union == set([0]):		# print "comp_tmp", comp_tmp, "previous sets:", previous_sets, "neighbours", neighbours, "forbidden", forbidden	# if len(previous_sets) == 0 and len(neighbours) == 0:		# print "comp_tmp", comp_tmp, "previous sets:", previous_sets, "neighbours", neighbours, "forbidden", forbidden	if len(nodes_to_place) == 0:		# we have a partition		previous_sets.append(comp_tmp)		# print previous_sets		print_partition(previous_sets)		# way to make a copy of the list rather than modify it?		previous_sets.remove(comp_tmp)		return	if len(neighbours) != 0:		# possibility to extend comp_tmp with a vertex from neighbours		# simpler way to get vn without modifying neighbours?		vn = neighbours.pop()		neighbours.add(vn)		new_comp_tmp = comp_tmp.union(set([vn]))		new_neighbours = neighbours.difference(set([vn]))		new_neighbours.update(g[vn])		new_neighbours.difference_update(forbidden)		new_forbidden = forbidden.union(set([vn]))		if vn not in nodes_to_place:			print 'gen_partitions_aux: Problem'			return		new_nodes_to_place = nodes_to_place.difference(set([vn]))		# print "Recursive call, extend comp_tmp with first neighbour"		gen_partitions_aux(			g,			n,			new_comp_tmp,			new_neighbours,			new_forbidden,			previous_sets,			previous_sets_union,			new_nodes_to_place,			)		# exploring the possibility to extend comp_tmp without using vn		new_neighbours = neighbours.difference(set([vn]))		new_forbidden = forbidden.union(set([vn]))		# print "rec call, extend comp_tmp with other neighourm, comp_tmp", comp_tmp		gen_partitions_aux(			g,			n,			comp_tmp,			new_neighbours,			new_forbidden,			previous_sets,			previous_sets_union,			nodes_to_place,			)	else:		# all possibilities to extend comp_tmp have been considered,		# new consider comp_tmp as a whole set		# start a new set with first vertex from nodes_to_place		# simpler way to get a vertex from node_to_place without modifying it?		v = nodes_to_place.pop()		nodes_to_place.add(v)		new_nodes_to_place = nodes_to_place.difference(set([v]))		# print "previous sets:", previous_sets		previous_sets.append(comp_tmp)		# print "previous sets after appending comp_tmp:", previous_sets		previous_sets_union.update(comp_tmp)		new_forbidden = previous_sets_union.copy()		new_forbidden.add(v)		new_comp_tmp = set([v])		# if previous_sets_union == set([0]):			# print "v:", v, "g[v]", g[v]		new_neighbours = g[v].copy()		new_neighbours.difference_update(new_forbidden)		# print "about to call recursively, new_previous sets:", new_previous_sets		# print "rec call, comp_tmp is a new set"		gen_partitions_aux(			g,			n,			new_comp_tmp,			new_neighbours,			new_forbidden,			previous_sets,			previous_sets_union,			new_nodes_to_place,			)		# way to make a copy of the list rather than modifying it?		previous_sets.remove(comp_tmp)		previous_sets_union.difference_update(comp_tmp)# same as above, but does not allow partitions in which vertices are inoslate in# their own setdef gen_partitions_prune_aux(g, comp_tmp, neighbours, forbidden):    #g=set of all nodes    #comp_tmp = ?    #neighbours = neighbours of vertices in comp_tmp not in forbidden    #forbidden = list of nodes which comp_tmp cannot stretch into?    #vn = ?	global b,ii,previous_sets,previous_sets_union,nodes_to_place	# if previous_sets_union == set([0]):		# print "comp_tmp", comp_tmp, "previous sets:", previous_sets, "neighbours", neighbours, "forbidden", forbidden	# if len(previous_sets) == 0 and len(neighbours) == 0:		# print "comp_tmp", comp_tmp, "previous sets:", previous_sets, "neighbours", neighbours, "forbidden", forbidden	if len(neighbours) != 0:		# possibility to extend comp_tmp with a vertex from neighbours		# simpler way to get vn without modifying neighbours?		vn = neighbours.pop()		neighbours.add(vn)		# new_comp_tmp = comp_tmp.union(set([vn]))		comp_tmp.add(vn)		new_neighbours = neighbours.difference(set([vn]))		new_neighbours.update(g[vn])		new_neighbours.difference_update(forbidden)		# new_forbidden = forbidden.union(set([vn]))		forbidden.add(vn)		# new_nodes_to_place = nodes_to_place.difference(set([vn]))		nodes_to_place.remove(vn)		# print "Recursive call, extend comp_tmp with first neighbour"		# gen_partitions_prune_aux(g, new_comp_tmp, new_neighbours, new_forbidden, previous_sets, previous_sets_union, new_nodes_to_place)		gen_partitions_prune_aux(g, comp_tmp, new_neighbours, forbidden)		nodes_to_place.add(vn)		comp_tmp.remove(vn)		# exploring the possibility to extend comp_tmp without using vn		new_neighbours = neighbours.difference(set([vn]))		# new_forbidden = forbidden.union(set([vn]))		# print "rec call, extend comp_tmp with other neighourm, comp_tmp", comp_tmp		gen_partitions_prune_aux(g, comp_tmp, new_neighbours, forbidden)		forbidden.remove(vn)	else:		# all possibilities to extend comp_tmp have been considered,		# new consider comp_tmp as a whole set		# if comp_tmp has only one element we do not want it as a whole set		#if len(comp_tmp) == 1:		#	return		if len(nodes_to_place) == 0:			# we have a partition			previous_sets.append(comp_tmp)			# print previous_sets			print_partition(previous_sets)			# way to make a copy of the list rather than modify it?			previous_sets.remove(comp_tmp)			return		# start a new set with first vertex from nodes_to_place		# simpler way to get a vertex from node_to_place without modifying it?		v = nodes_to_place.pop()		# nodes_to_place.add(v)		# new_nodes_to_place=nodes_to_place.difference(set([v]))		# print "previous sets:", previous_sets		previous_sets.append(comp_tmp)		# print "previous sets after appending comp_tmp:", previous_sets		previous_sets_union.update(comp_tmp)		new_forbidden = previous_sets_union.copy()		new_forbidden.add(v)		new_comp_tmp = set([v])		# if previous_sets_union == set([0]):			# print "v:", v, "g[v]", g[v]		new_neighbours = g[v].copy()		new_neighbours.difference_update(new_forbidden)		# print "about to call recursively, new_previous sets:", new_previous_sets		# print "rec call, comp_tmp is a new set"		# gen_partitions_prune_aux(g, new_comp_tmp, new_neighbours, new_forbidden, previous_sets, previous_sets_union, new_nodes_to_place)		gen_partitions_prune_aux(g, new_comp_tmp, new_neighbours,								new_forbidden)		nodes_to_place.add(v)		# way to make a copy of the list rather than modifying it?		previous_sets.remove(comp_tmp)		previous_sets_union.difference_update(comp_tmp)#if __name__ == '__main__':comp_tmp = set([0])forbidden = set([0])previous_sets = []previous_sets_union = set()nodes_to_place = set()b = [[]]ii = 0def find_all_partitions(g):    global b,ii,comp_tmp,forbidden,previous_sets,previous_sets_union,nodes_to_place    comp_tmp = set([0])     forbidden = set([0])    previous_sets = []    previous_sets_union = set()    nodes_to_place = set()    b = [[]]    ii = 0    # g=from_file("graph_file")    # g=from_stdin()    n = len(g)    # print n    for i in range(n):    	nodes_to_place.add(i)    nodes_to_place.remove(0)    neighbours = g[0]    # print nodes_to_place    gen_partitions_prune_aux(g, comp_tmp, neighbours, forbidden)    b.pop()    return b    # gen_conn_aux_size(g,comp_tmp,7,neighbours,forbidden)